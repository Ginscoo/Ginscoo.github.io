## 范型介绍
范型（Generics）是Java编程语言中的一种特性，它提供了参数化类型的能力，允许在类、接口、方法的声明中使用类型参数。通过范型，我们可以编写更通用、灵活和类型安全的代码。

使用范型的主要目的是实现类型的参数化，使代码能够适用于不同的数据类型，而不需要针对每种数据类型编写重复的代码。范型可以应用于类、接口、方法等多个层面，它可以与集合类、自定义数据结构、泛型方法等结合使用。

范型在声明时使用尖括号（<>）来指定类型参数，可以是任何合法的Java类型，如类、接口、数组等。范型类型参数常用的命名约定有T、E、K、V等，但实际上可以根据需求自定义类型参数的名称。

通过使用范型，我们可以提高代码的可重用性和灵活性，并在编译时进行更严格的类型检查，避免在运行时出现类型转换错误。范型还能够提供更好的代码可读性和维护性，因为它可以在代码中明确表达数据类型的意图。

例如，使用范型可以定义一个通用的容器类，可以存储任意类型的数据，而不需要为每种数据类型都编写一个专门的容器类。范型还可以应用于集合类、函数式接口、线程安全性等方面，为Java编程带来了更多的灵活性和类型安全性。

## 范型擦除
范型擦除（Type Erasure）是Java中范型的一个特性，它指的是在编译期间将范型类型信息擦除，使得范型在运行时成为原始类型（Raw Type）。

在Java中，范型类型参数只存在于代码的编译阶段，编译器会在编译过程中检查和验证范型类型的正确性，但在生成的字节码中，范型类型信息会被擦除。这意味着在运行时，无法通过反射等方式获取范型的具体类型信息。

范型擦除的原因是为了保持Java的向后兼容性，范型是在Java 5引入的新特性，为了与之前的Java版本兼容，编译器将范型擦除为原始类型，这样可以让旧的代码能够在新版本的Java中继续运行。

范型擦除也导致了一些限制和约束，例如无法直接创建范型类型的实例、无法在范型类型中使用基本类型等。为了弥补这些限制，Java提供了通配符（Wildcard）和类型边界（Type Bound）等特性，以便更灵活地处理范型类型。

尽管范型在运行时会失去具体的类型信息，但在编译期间它仍然可以提供类型安全性和编译时类型检查的好处。范型擦除使得Java的范型在性能上更高效，并且与旧版本的代码兼容，但也需要开发人员在使用范型时注意潜在的类型安全问题。

## 范型擦除扩展
在范型擦除后，Java编译器会进行类型擦除，将范型类型转换为它们的上界类型或Object类型。这意味着在编译时，无法直接访问范型类型的具体信息，例如范型类型的实际类型参数。

在其他代码中调用对应范型方法时，编译器会根据方法的声明和范型类型的上界进行安全检查。编译器将使用类型擦除后的上界类型进行类型检查，以确保调用的方法与上界类型是兼容的。如果范型类型的上界类型与调用方法的参数类型不匹配，编译器将产生编译错误。

举例来说，假设有一个范型类Box<T>，其中的方法void addItem(T item)用于添加元素。在使用时，如果创建了一个Box<String>的实例，并调用addItem方法传入一个Integer类型的参数，编译器将产生编译错误，因为String和Integer不兼容。

尽管在编译时无法访问范型类型的具体信息，但编译器通过类型检查和类型推断等机制，确保在调用范型方法时保持类型安全。这样可以在编译阶段捕获一些类型相关的错误，提高代码的可靠性和可维护性。

通配符（Wildcard）和类型边界（Type Bound）是Java范型中用于限定范型类型的特性。

通配符（Wildcard）用于表示未知类型，通过使用?符号来表示。它可以用作范型类型的参数，用于接收不确定的类型。

## 通配符（Wildcard）和类型边界（Type Bound）
在范型类型中，通配符可以分为两种类型：

上界通配符（Upper Bounded Wildcard）：使用extends关键字表示，可以接受范型类型及其子类型。例如，List<? extends Number>表示接受任意类型的List，但类型必须是Number或其子类型。

下界通配符（Lower Bounded Wildcard）：使用super关键字表示，可以接受范型类型及其父类型。例如，List<? super Integer>表示接受任意类型的List，但类型必须是Integer或其父类型。

类型边界（Type Bound）用于限制范型类型的具体类型范围。通过使用类型边界，我们可以指定范型类型必须是特定类型或其子类型。

类型边界可以分为两种类型：

上界类型边界（Upper Type Bound）：使用extends关键字表示，可以限制范型类型为指定类型或其子类型。例如，<T extends Number>表示范型类型T必须是Number或其子类型。

下界类型边界（Lower Type Bound）：使用super关键字表示，可以限制范型类型为指定类型或其父类型。例如，<T super Integer>表示范型类型T必须是Integer或其父类型。

通配符和类型边界的使用可以增加范型类型的灵活性和安全性。它们使得我们能够处理未知类型、限制类型的范围，并在编译时进行类型检查，提高代码的可读性和可维护性。

## 参考文档
* [官方范型教程链接 - https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html](https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html)
* [特定情况下获取范型实际类型原理分析 - https://developer.aliyun.com/article/1226646?utm_content=g_1000372882](https://developer.aliyun.com/article/1226646?utm_content=g_1000372882)
* [运行时获取范型方法 - http://gafter.blogspot.com/2006/12/super-type-tokens.html](http://gafter.blogspot.com/2006/12/super-type-tokens.html) 或者参考`jackson`的`TypeRefrence`类